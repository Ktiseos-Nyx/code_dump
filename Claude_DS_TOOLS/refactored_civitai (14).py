# dataset_tools/vendored_sdpr/format/__init__.py

__author__ = "receyuki & Ktiseos Nyx"
__filename__ = "__init__.py"
__copyright__ = "Copyright 2023, Receyuki; Modified 2025, Ktiseos Nyx"
__email__ = "receyuki@gmail.com; your_email@example.com"

"""
AI Image Generation Metadata Parsing Framework

This module provides a comprehensive collection of precision-engineered parsers
for extracting metadata from images generated by various AI image generation tools.

The framework includes support for:
- Text-based formats (A1111, Forge, Yodayo)
- JSON-based formats (ComfyUI, DrawThings, EasyDiffusion, etc.)
- Steganographic formats (NovelAI LSB, Midjourney XMP)
- IPTC formats (Mochi Diffusion)
- Specialized workflow formats (TensorArt, SwarmUI)

Each parser is engineered with:
- Robust format detection and validation
- Comprehensive error handling
- Advanced feature extraction
- Production-ready reliability
- Extensive debugging capabilities
"""

import logging
from typing import Dict, List, Optional, Type, Any
from dataclasses import dataclass, field


# === Core Framework Components ===
from .base_format import BaseFormat
from .utility import (
    StringProcessor, DataStructureProcessor, ValidationUtilities,
    remove_quotes, add_quotes, concat_strings, merge_dict, merge_str_to_tuple,
    smart_string_split, format_key_for_display, build_settings_string
)

# === Text-Based Format Parsers ===
from .a1111 import A1111
from .forge_format import ForgeFormat
from .yodayo import YodayoFormat

# === JSON-Based Format Parsers ===
from .civitai import CivitaiFormat
from .comfyui import ComfyUI
from .drawthings import DrawThings
from .easydiffusion import EasyDiffusion
from .fooocus import Fooocus
from .invokeai import InvokeAI
from .ruinedfooocus import RuinedFooocusFormat
from .swarmui import SwarmUI
from .tensorart import TensorArtFormat

# === Specialized Format Parsers ===
from .midjourney import MidjourneyFormat
from .mochi_diffusion import MochiDiffusionFormat
from .novelai import NovelAI


@dataclass
class ParserInfo:
    """Information about a registered parser"""
    name: str
    parser_class: Type[BaseFormat]
    category: str
    description: str
    supported_formats: List[str]
    requires_special_handling: bool = False
    dependencies: Optional[List[str]] = None


@dataclass
class ParserRegistryConfig:
    """Configuration for the parser registry system"""
    
    # Parser categories for systematic organization
    PARSER_CATEGORIES: Dict[str, str] = field(default_factory=lambda: {
        "base": "Core Framework Components",
        "text": "Text-Based Format Parsers", 
        "json": "JSON-Based Format Parsers",
        "specialized": "Specialized Format Parsers",
        "workflow": "Workflow Format Parsers",
        "steganographic": "Steganographic Format Parsers",
    })
    
    # Parser registry with comprehensive metadata
    PARSER_REGISTRY: Dict[str, ParserInfo] = field(default_factory=lambda: {
        # Base framework
        "BaseFormat": ParserInfo(
            name="BaseFormat",
            parser_class=BaseFormat,
            category="base",
            description="Base class for all format parsers",
            supported_formats=["base"],
        ),
        
        # Text-based parsers
        "A1111": ParserInfo(
            name="A1111",
            parser_class=A1111,
            category="text",
            description="Automatic1111 WebUI text format parser",
            supported_formats=["a1111_text", "webui_text"],
        ),
        "ForgeFormat": ParserInfo(
            name="ForgeFormat", 
            parser_class=ForgeFormat,
            category="text",
            description="Forge/ReForge advanced signature detection parser",
            supported_formats=["forge_text", "reforge_text"],
            dependencies=["A1111"],
        ),
        "YodayoFormat": ParserInfo(
            name="YodayoFormat",
            parser_class=YodayoFormat,
            category="text", 
            description="Yodayo/Moescape derivative detection parser",
            supported_formats=["yodayo_text", "moescape_text"],
            dependencies=["A1111"],
        ),
        
        # JSON-based parsers
        "CivitaiFormat": ParserInfo(
            name="CivitaiFormat",
            parser_class=CivitaiFormat,
            category="json",
            description="Civitai multi-format parser with mojibake handling",
            supported_formats=["civitai_comfyui_json", "civitai_a1111_text"],
        ),
        "ComfyUI": ParserInfo(
            name="ComfyUI",
            parser_class=ComfyUI,
            category="workflow",
            description="ComfyUI workflow traversal and analysis parser",
            supported_formats=["comfyui_workflow", "comfyui_api"],
        ),
        "DrawThings": ParserInfo(
            name="DrawThings",
            parser_class=DrawThings,
            category="json",
            description="DrawThings JSON format parser with robust validation",
            supported_formats=["drawthings_json"],
        ),
        "EasyDiffusion": ParserInfo(
            name="EasyDiffusion",
            parser_class=EasyDiffusion,
            category="json",
            description="EasyDiffusion multi-source parsing system",
            supported_formats=["easydiffusion_json"],
        ),
        "Fooocus": ParserInfo(
            name="Fooocus",
            parser_class=Fooocus,
            category="json",
            description="Fooocus comprehensive feature detection parser",
            supported_formats=["fooocus_json"],
        ),
        "InvokeAI": ParserInfo(
            name="InvokeAI",
            parser_class=InvokeAI,
            category="json",
            description="InvokeAI multi-format support system",
            supported_formats=["invokeai_metadata", "sd_metadata", "dream_format"],
        ),
        "RuinedFooocusFormat": ParserInfo(
            name="RuinedFooocusFormat",
            parser_class=RuinedFooocusFormat,
            category="json",
            description="RuinedFooocus fork-specific intelligence parser",
            supported_formats=["ruinedfooocus_json"],
        ),
        "SwarmUI": ParserInfo(
            name="SwarmUI",
            parser_class=SwarmUI,
            category="workflow",
            description="SwarmUI swarm intelligence data location parser",
            supported_formats=["swarmui_json", "swarmui_nested"],
        ),
        "TensorArtFormat": ParserInfo(
            name="TensorArtFormat",
            parser_class=TensorArtFormat,
            category="workflow",
            description="TensorArt ComfyUI workflow intelligence parser",
            supported_formats=["tensorart_comfyui"],
        ),
        
        # Specialized parsers
        "MidjourneyFormat": ParserInfo(
            name="MidjourneyFormat",
            parser_class=MidjourneyFormat,
            category="specialized",
            description="Midjourney XMP and parameter analysis parser",
            supported_formats=["midjourney_xmp", "midjourney_parameters"],
            requires_special_handling=True,
        ),
        "MochiDiffusionFormat": ParserInfo(
            name="MochiDiffusionFormat",
            parser_class=MochiDiffusionFormat,
            category="specialized",
            description="Mochi Diffusion IPTC metadata precision parser",
            supported_formats=["mochi_iptc"],
        ),
        "NovelAI": ParserInfo(
            name="NovelAI",
            parser_class=NovelAI,
            category="steganographic",
            description="NovelAI LSB steganography extraction parser",
            supported_formats=["novelai_legacy", "novelai_stealth"],
            requires_special_handling=True,
        ),
    })


class ParserRegistry:
    """Advanced parser registry with comprehensive management capabilities"""
    
    def __init__(self, config: Optional[ParserRegistryConfig] = None):
        self.config = config or ParserRegistryConfig()
        self.logger = logging.getLogger(__name__)
        self._registration_attempted = False
        self._registration_successful = False
        
    def get_all_parsers(self) -> Dict[str, ParserInfo]:
        """Get all registered parsers"""
        return self.config.PARSER_REGISTRY.copy()
        
    def get_parsers_by_category(self, category: str) -> Dict[str, ParserInfo]:
        """Get parsers filtered by category"""
        return {
            name: info for name, info in self.config.PARSER_REGISTRY.items()
            if info.category == category
        }
        
    def get_parser_info(self, parser_name: str) -> Optional[ParserInfo]:
        """Get information about a specific parser"""
        return self.config.PARSER_REGISTRY.get(parser_name)
        
    def validate_dependencies(self) -> Dict[str, List[str]]:
        """Validate parser dependencies and return any issues"""
        issues = {}
        
        for name, info in self.config.PARSER_REGISTRY.items():
            if info.dependencies:
                missing_deps = []
                for dep in info.dependencies:
                    if dep not in self.config.PARSER_REGISTRY:
                        missing_deps.append(dep)
                        
                if missing_deps:
                    issues[name] = missing_deps
                    
        return issues
        
    def get_framework_statistics(self) -> Dict[str, Any]:
        """Get comprehensive framework statistics"""
        stats = {
            "total_parsers": len(self.config.PARSER_REGISTRY),
            "categories": {},
            "supported_formats": set(),
            "special_handling_count": 0,
            "dependency_count": 0,
        }
        
        for info in self.config.PARSER_REGISTRY.values():
            # Count by category
            category = info.category
            stats["categories"][category] = stats["categories"].get(category, 0) + 1
            
            # Collect supported formats
            stats["supported_formats"].update(info.supported_formats)
            
            # Count special handling requirements
            if info.requires_special_handling:
                stats["special_handling_count"] += 1
                
            # Count dependencies
            if info.dependencies:
                stats["dependency_count"] += len(info.dependencies)
                
        stats["supported_formats"] = list(stats["supported_formats"])
        return stats
        
    def attempt_metadata_engine_registration(self) -> bool:
        """Attempt to register parsers with the metadata engine"""
        if self._registration_attempted:
            return self._registration_successful
            
        self._registration_attempted = True
        
        try:
            from ...metadata_engine import register_parser_class
            
            # Validate dependencies first
            dependency_issues = self.validate_dependencies()
            if dependency_issues:
                self.logger.warning(f"Parser dependency issues found: {dependency_issues}")
                
            # Register all parsers
            successful_registrations = 0
            
            for name, info in self.config.PARSER_REGISTRY.items():
                try:
                    register_parser_class(name, info.parser_class)
                    successful_registrations += 1
                    self.logger.debug(f"Registered parser: {name}")
                except Exception as e:
                    self.logger.error(f"Failed to register parser {name}: {e}")
                    
            self._registration_successful = successful_registrations > 0
            
            if self._registration_successful:
                self.logger.info(f"Successfully registered {successful_registrations}/{len(self.config.PARSER_REGISTRY)} parsers")
            else:
                self.logger.error("Failed to register any parsers")
                
            return self._registration_successful
            
        except ImportError as e:
            self.logger.debug(f"Metadata engine not available for registration: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error during parser registration: {e}")
            return False


# === Global Registry Instance ===
_parser_registry = ParserRegistry()


# === Public Interface Functions ===

def get_available_parsers() -> Dict[str, ParserInfo]:
    """Get all available parsers with their information"""
    return _parser_registry.get_all_parsers()


def get_parsers_by_category(category: str) -> Dict[str, ParserInfo]:
    """Get parsers filtered by category"""
    return _parser_registry.get_parsers_by_category(category)


def get_framework_info() -> Dict[str, Any]:
    """Get comprehensive framework information"""
    stats = _parser_registry.get_framework_statistics()
    
    return {
        "framework_name": "AI Image Generation Metadata Parsing Framework",
        "version": "2.0.0-engineered",
        "author": "receyuki & Ktiseos Nyx",
        "statistics": stats,
        "categories": _parser_registry.config.PARSER_CATEGORIES,
        "registration_status": {
            "attempted": _parser_registry._registration_attempted,
            "successful": _parser_registry._registration_successful,
        }
    }


def validate_framework() -> Dict[str, Any]:
    """Validate the framework configuration and dependencies"""
    validation_result = {
        "is_valid": True,
        "issues": [],
        "warnings": [],
        "dependency_issues": {},
    }
    
    # Check dependencies
    dependency_issues = _parser_registry.validate_dependencies()
    if dependency_issues:
        validation_result["dependency_issues"] = dependency_issues
        validation_result["warnings"].append(f"Found {len(dependency_issues)} parsers with missing dependencies")
        
    # Check for duplicate supported formats
    format_providers = {}
    for name, info in _parser_registry.get_all_parsers().items():
        for fmt in info.supported_formats:
            if fmt not in format_providers:
                format_providers[fmt] = []
            format_providers[fmt].append(name)
            
    duplicate_formats = {fmt: providers for fmt, providers in format_providers.items() if len(providers) > 1}
    if duplicate_formats:
        validation_result["warnings"].append(f"Found {len(duplicate_formats)} formats supported by multiple parsers")
        validation_result["duplicate_formats"] = duplicate_formats
        
    return validation_result


# === Module Initialization ===

def _initialize_module():
    """Initialize the format module and attempt parser registration"""
    # Attempt registration with metadata engine
    registration_success = _parser_registry.attempt_metadata_engine_registration()
    
    # Validate framework
    validation = validate_framework()
    
    # Log initialization results
    logger = logging.getLogger(__name__)
    stats = _parser_registry.get_framework_statistics()
    
    logger.info(f"Format module initialized with {stats['total_parsers']} parsers")
    logger.info(f"Categories: {', '.join(stats['categories'].keys())}")
    logger.info(f"Supported formats: {len(stats['supported_formats'])}")
    
    if registration_success:
        logger.info("Parser registration with metadata engine: SUCCESS")
    else:
        logger.debug("Parser registration with metadata engine: UNAVAILABLE")
        
    if validation["warnings"]:
        for warning in validation["warnings"]:
            logger.warning(warning)


# === Export Lists ===

# Core framework components
__framework_exports__ = [
    "BaseFormat",
    "get_available_parsers",
    "get_parsers_by_category", 
    "get_framework_info",
    "validate_framework",
]

# Utility functions
__utility_exports__ = [
    "StringProcessor",
    "DataStructureProcessor", 
    "ValidationUtilities",
    "remove_quotes",
    "add_quotes",
    "concat_strings",
    "merge_dict",
    "merge_str_to_tuple",
    "smart_string_split",
    "format_key_for_display",
    "build_settings_string",
]

# Text-based parsers
__text_parser_exports__ = [
    "A1111",
    "ForgeFormat",
    "YodayoFormat",
]

# JSON-based parsers  
__json_parser_exports__ = [
    "CivitaiFormat",
    "DrawThings",
    "EasyDiffusion",
    "Fooocus", 
    "InvokeAI",
    "RuinedFooocusFormat",
]

# Workflow parsers
__workflow_parser_exports__ = [
    "ComfyUI",
    "SwarmUI",
    "TensorArtFormat",
]

# Specialized parsers
__specialized_parser_exports__ = [
    "MidjourneyFormat",
    "MochiDiffusionFormat", 
    "NovelAI",
]

# Complete export list
__all__ = (
    __framework_exports__ +
    __utility_exports__ +
    __text_parser_exports__ +
    __json_parser_exports__ +
    __workflow_parser_exports__ +
    __specialized_parser_exports__
)

# Initialize the module
_initialize_module()